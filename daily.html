<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Daily Rainfall Totals</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="style.css" />
</head>
<body class="light">
  <div id="site-header"></div>

  <main class="container">
    <section class="header-block">
      <h2>Daily Rainfall Totals</h2>
      <div class="meta">
        <div id="clock">--:--:--</div>
        <div id="lastUpdated">Aggregated from per-interval data</div>
      </div>
    </section>

    <section class="card chart-card">
      <div class="chart-title">Last 30 days (mm)</div>
      <canvas id="dailyRainChart"></canvas>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- Load header include via import (no duplicate <script src>) -->
  <script type="module">
    // ---------- Header include ----------
    import { injectHeader } from './partials/include.js?v=13';
    await injectHeader();

    // ---------- Live clock ----------
    const pad2 = n => String(n).padStart(2,'0');
    const clockFmt = d => `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;
    const clockEl = document.getElementById("clock");
    setInterval(() => clockEl.textContent = clockFmt(new Date()), 1000);

    // ---------- Supabase config (your real values) ----------
    const PROJECT_URL = "https://scbekobcwdxrfvdiofjp.supabase.co";
    const ANON_KEY    = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNjYmVrb2Jjd2R4cmZ2ZGlvZmpwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ3MDg4ODgsImV4cCI6MjA3MDI4NDg4OH0.FTSxV5J-vPN59NCrplGRIEvk9NFZ3-0y8yya-YxKnjM";

    // If your table also stores per-interval values, set true (column: rainfall_mm_interval)
    const HAS_INTERVAL_COLUMN = false;

    // If your daily roll-over is at a specific hour (e.g., 07:00 WIB), set here
    const DAILY_RESET_HOUR_LOCAL = 0; // 0 = midnight; set to 7 to match your ESP32 reset

    import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
    const supabase = createClient(PROJECT_URL, ANON_KEY);

    // ---------- Helpers ----------
    function showErrorBanner(msg) {
      let b = document.getElementById('errBanner');
      if (!b) {
        b = document.createElement('div');
        b.id = 'errBanner';
        b.style.cssText = `
          position: fixed; left: 12px; right: 12px; bottom: 12px;
          background: #fee2e2; color:#991b1b; border:1px solid #fecaca;
          padding:10px 12px; border-radius:10px; box-shadow:0 10px 30px rgba(0,0,0,.15);
          font: 600 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; z-index: 9999;
        `;
        document.body.appendChild(b);
      }
      b.textContent = msg;
      setTimeout(()=>{ if (b) b.remove(); }, 8000);
    }

    const css = (v,f)=>getComputedStyle(document.body).getPropertyValue(v).trim()||f;
    const gridColor = () => {
      const v = css('--muted','#6b7280');
      return v.startsWith('hsl') ? v.replace(')', ' / 0.22)') : (v + '22');
    };

    // Prefer device ts if present; else created_at
    const tsOf = row => row.ts ?? row.created_at;

    // Resolve table name underscore vs hyphen
    let resolvedTable = 'weather_readings';
    async function resolveTable(selectCols) {
      let r = await supabase.from('weather_readings').select(selectCols).limit(1);
      if (!r.error) { resolvedTable = 'weather_readings'; return; }
      r = await supabase.from('weather-readings').select(selectCols).limit(1);
      if (!r.error) { resolvedTable = 'weather-readings'; return; }
      console.error('Table read error:', r.error);
      showErrorBanner('Cannot read table. Check RLS (SELECT) & table name.');
    }

    // Build columns to fetch (include ts as fallback)
    const cols = HAS_INTERVAL_COLUMN
      ? "created_at, ts, rainfall_mm, rainfall_mm_interval"
      : "created_at, ts, rainfall_mm";

    await resolveTable(cols);

    // Fetch all rows ascending (client-side aggregate)
    const { data, error } = await supabase
      .from(resolvedTable)
      .select(cols)
      .order("created_at", { ascending: true });

    if (error) {
      console.error("Initial load error:", error);
      if (error.code === '42501' || error.code === 'PGRST301' || (error.message||'').toLowerCase().includes('permission')) {
        showErrorBanner('Anon cannot SELECT. Add SELECT policy on your table.');
      }
    }

    // ---- Aggregate by local day, with optional non-midnight reset ----
    const dayTotals = new Map();   // key -> total mm
    const dayMaxCum = new Map();   // fallback when interval not available

    function dayKeyWithReset(date) {
      // Shift by DAILY_RESET_HOUR_LOCAL so "day" starts at that hour
      const d = new Date(date);
      const shiftMs = DAILY_RESET_HOUR_LOCAL * 60 * 60 * 1000;
      const shifted = new Date(d.getTime() - shiftMs);
      const y = shifted.getFullYear();
      const m = String(shifted.getMonth()+1).padStart(2,'0');
      const day = String(shifted.getDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }

    (data || []).forEach(row => {
      const tsISO = tsOf(row);
      if (!tsISO) return;
      const ts = new Date(tsISO);
      const key = dayKeyWithReset(ts);

      if (HAS_INTERVAL_COLUMN && row.rainfall_mm_interval != null) {
        const v = Number(row.rainfall_mm_interval) || 0;
        dayTotals.set(key, (dayTotals.get(key) || 0) + v);
      } else {
        const cum = Number(row.rainfall_mm || 0);
        dayMaxCum.set(key, Math.max(dayMaxCum.get(key) || 0, cum));
      }
    });

    if (!HAS_INTERVAL_COLUMN) {
      dayMaxCum.forEach((maxCum, key) => dayTotals.set(key, maxCum));
    }

    // Keep last 30 days
    const today = new Date();
    const cutoff = new Date(today);
    cutoff.setDate(cutoff.getDate() - 30);

    const labels = [];
    const values = [];
    [...dayTotals.entries()]
      .sort(([a],[b]) => a.localeCompare(b))
      .forEach(([key, val]) => {
        const d = new Date(key + "T00:00:00");
        if (d >= cutoff) { labels.push(key); values.push(val); }
      });

    // Chart
    const ctx = document.getElementById("dailyRainChart").getContext("2d");
    const chart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels,
        datasets: [{
          label: "Daily rainfall (mm)",
          data: values,
          backgroundColor: "rgba(56,189,248,0.6)"
        }]
      },
      options: {
        responsive: true, maintainAspectRatio: false,
        plugins: { legend: { labels: { color: css('--text','#0f172a') } } },
        scales: {
          x: { ticks: { color: css('--muted','#6b7280') }, grid: { color: gridColor() } },
          y: { ticks: { color: css('--muted','#6b7280') }, grid: { color: gridColor() }, beginAtZero: true }
        }
      }
    });

    // Retint on theme change
    const mo = new MutationObserver(() => {
      chart.options.plugins.legend.labels.color = css('--text','#0f172a');
      chart.options.scales.x.ticks.color = css('--muted','#6b7280');
      chart.options.scales.x.grid.color = gridColor();
      chart.options.scales.y.ticks.color = css('--muted','#6b7280');
      chart.options.scales.y.grid.color = gridColor();
      chart.update('none');
    });
    mo.observe(document.body, { attributes: true, attributeFilter: ['class'] });

    // Last updated stamp
    const last = labels.at(-1);
    const lu = document.getElementById('lastUpdated');
    if (last && lu) lu.textContent = `Last aggregated day: ${last}`;
  </script>
</body>
</html>
